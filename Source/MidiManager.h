#pragma once

#include <JuceHeader.h>

//==============================================================================
/**
    MIDI Manager for AI Band Plugin
    
    Created by Sergie Code - Software Engineer & Programming Educator
    Part of the AI Band Ecosystem for musicians
    YouTube: https://www.youtube.com/@SergieCode
    GitHub: https://github.com/sergiecode
    
    This class handles loading, parsing, and managing MIDI files generated by
    the ai-band-backend. It provides functionality to load MIDI files into
    MidiBuffer objects for real-time playback.
*/
class MidiManager
{
public:
    //==============================================================================
    MidiManager();
    ~MidiManager();
    
    //==============================================================================
    /** Initialize the MIDI manager */
    void initialize();
    
    /** Prepare for audio processing */
    void prepareToPlay(double sampleRate, int samplesPerBlock);
    
    /** Release resources */
    void releaseResources();
    
    //==============================================================================
    /** Load a MIDI file and convert it to a MidiBuffer
        @param filePath     Path to the MIDI file
        @param buffer       Buffer to store the loaded MIDI data
        @returns true if successful
    */
    bool loadMidiFile(const juce::String& filePath, juce::MidiBuffer& buffer);
    
    /** Load MIDI data from memory
        @param data         MIDI file data in memory
        @param size         Size of the data in bytes
        @param buffer       Buffer to store the loaded MIDI data
        @returns true if successful
    */
    bool loadMidiFromMemory(const void* data, size_t size, juce::MidiBuffer& buffer);
    
    /** Save a MidiBuffer to a MIDI file
        @param buffer       Buffer containing MIDI data
        @param filePath     Output file path
        @returns true if successful
    */
    bool saveMidiFile(const juce::MidiBuffer& buffer, const juce::String& filePath);
    
    //==============================================================================
    /** Get the duration of loaded MIDI data in beats
        @param buffer       Buffer to analyze
        @returns duration in beats
    */
    double getMidiDurationInBeats(const juce::MidiBuffer& buffer) const;
    
    /** Get the tempo from MIDI data (if available)
        @param buffer       Buffer to analyze
        @returns tempo in BPM, or 120.0 if not found
    */
    double getTempoFromMidi(const juce::MidiBuffer& buffer) const;
    
    /** Get the time signature from MIDI data (if available)
        @param buffer       Buffer to analyze
        @param numerator    Time signature numerator
        @param denominator  Time signature denominator
        @returns true if time signature was found
    */
    bool getTimeSignatureFromMidi(const juce::MidiBuffer& buffer, int& numerator, int& denominator) const;
    
    //==============================================================================
    /** Convert beats to samples based on current sample rate and tempo
        @param beats        Beat position
        @param tempo        Tempo in BPM
        @returns sample position
    */
    int beatsToSamples(double beats, double tempo) const;
    
    /** Convert samples to beats based on current sample rate and tempo
        @param samples      Sample position
        @param tempo        Tempo in BPM
        @returns beat position
    */
    double samplesToBeats(int samples, double tempo) const;
    
    //==============================================================================
    /** Check if a file is a valid MIDI file
        @param filePath     Path to check
        @returns true if file appears to be a valid MIDI file
    */
    static bool isValidMidiFile(const juce::String& filePath);
    
    /** Get supported MIDI file extensions */
    static juce::StringArray getSupportedExtensions();

private:
    //==============================================================================
    double currentSampleRate;
    int currentBlockSize;
    
    //==============================================================================
    /** Convert a MidiFile to a MidiBuffer with proper timing
        @param midiFile     Source MIDI file
        @param buffer       Destination buffer
        @param tempoScale   Tempo scaling factor (1.0 = normal speed)
    */
    void convertMidiFileToBuffer(const juce::MidiFile& midiFile, juce::MidiBuffer& buffer, double tempoScale = 1.0);
    
    /** Process tempo events and calculate timing
        @param track        MIDI track to process
        @param ticksPerBeat MIDI ticks per quarter note
        @returns tempo map for timing calculations
    */
    struct TempoEvent
    {
        int tick;
        double tempo;
        double timeInSeconds;
    };
    
    std::vector<TempoEvent> buildTempoMap(const juce::MidiMessageSequence& track, int ticksPerBeat);
    
    /** Convert MIDI tick time to seconds using tempo map */
    double ticksToSeconds(int ticks, const std::vector<TempoEvent>& tempoMap, int ticksPerBeat) const;
    
    //==============================================================================
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MidiManager)
};
